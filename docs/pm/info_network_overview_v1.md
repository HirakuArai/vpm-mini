# info_network_overview_v1

## 1. 目的（Why）

VPM（Virtual Project Manager）は、「プロジェクトの現実の状態」を理解し、説明し、次の一手を提案するために動く。

そのためには、VPMの内部に

- プロジェクトの現実を「こうなっている / こうなっていてほしい」として写した
- 一貫した「頭の中の地図」

が必要になる。

このドキュメントでは、その地図を

- **info_node**（単位化された情報の点）
- **info_relation**（点同士の関係を表す線）

からなる **情報ネットワーク（info_network）** として定義し、その **v1 のルールブック**を定める。

---

## 2. 基本の考え方（Concepts）

### 2.1 Project と VPM の関係

- **Project**  
  = 「あるスコープで切り取った現実の状態」

  - どこからどこまでを「このプロジェクト」とみなすか（境界・範囲＝scope）は、人間が決める。
  - 例: 「vpm-mini の Phase 2」「Teradata EOL 対応プロジェクト」など。

- **VPM**  
  = そのスコープで見た現実の「こうなっているはず」という写像（モデル）

  - すべての事実・目的・期待・制約・前提・決定を info_network として持つ。

ここで重要なのは：

> **現実と info_network のあいだには常にズレがある。  
> そのズレを検知し、埋めていく営みそのものが、VPM を使っている状態である。**

VPMは「常に完全最新」を目指すのではなく、

- 「いま何がどこまでわかっているか」
- 「どこにズレがあり、それをどう埋めるか」

を扱う仕組みとして設計する。

### 2.2 状態を構成する3成分

プロジェクトの状態を、まずは次の3つの成分に分けて考える。

1. **Purpose（目的）**  
   - 何を実現したいか
   - なぜそれをやるのか / 誰にとってどんな価値があるか

2. **State（状態）**  
   - **Expected State（期待状態）**  
     - 「こうなっていてほしい」「こうなったら達成と言える」
   - **Actual State（現実状態）**  
     - 「いま実際はこうなっている」という観測結果

3. **Constraints & Assumptions（制約と前提）**  
   - **Constraint（制約）**  
     - 超えてはいけない条件（コスト上限・扱ってよいデータ範囲など）
   - **Assumption（前提）**  
     - そうだと仮定しているが、変わりうる条件（「このAPIは当面使えるはず」など）

この3成分を「ばらけたまま」扱うのではなく、

- ひとつひとつを info_node として単位化し、
- 相互の関係（因果・階層・依存）を info_relation として張ることで、

**「事象目的空間」を“網目（ネットワーク）”として扱う**のが info_network の基本発想である。

---

## 3. info_network の全体像

- **点**：`info_node`  
  → 「単位化された情報 1つ分」

- **線**：`info_relation`  
  → 「info_node 同士の関係（因果・階層・依存）」

- **全体**：  
  → `info_node` と `info_relation` からなる意味付きグラフ（DAG を目指す）

このネットワークを、

- 説明するときの「知識ベース」
- ズレを検知するときの「比較対象」
- 次の一手を考えるときの「構造」

として、VPM（Kai）が利用する。

---

## 4. info_node v1

### 4.1 役割

`info_node` は、プロジェクトに関する **単位化された情報 1つ分** を表す。

- 1つのノードは、
  - 「どのプロジェクトの」
  - 「どの対象（subject）について」
  - 「どんな意味の情報（kind）か」
  - 「何と言っているのか（statement）」
- を表現する。

### 4.2 フィールド一覧（v1）

必須フィールド：

- `id`  
  - ノードを一意に識別するID（文字列）
- `project_id`  
  - このノードが属するプロジェクト（例: `"vpm-mini"`, `"teradata-eol"`)
- `subject`  
  - 何についての情報か（例: `"phase2"`, `"p2-2-hello-ksvc@dev"`）
- `kind`  
  - 情報の種類（後述）
- `statement`  
  - 日本語 or 英語の 1 文で書かれた内容

推奨フィールド：

- `phase`（任意）  
  - プロジェクト内のフェーズ（例: `"phase2"`)
- `lane`（任意）  
  - レーン / トラック（例: `"infra"`, `"pm_snapshot"`, `"doc_update"`)
- `scope`（任意だが重要）  
  - このノードが属する「意味の塊」（例: `"phase2-kickoff"`, `"phase2-p2-2-hello"`)
- `status`（任意）  
  - `active` / `done` / `obsolete` など
- `author`（任意）  
  - このノードを記録した人/ロール（例: `"kei"`, `"kai"`, `"aya"`）
- `created_at`（任意）  
  - ISO8601形式のタイムスタンプ
- `evidence_refs`（任意）  
  - 実測値の証拠となるログ・PR・ドキュメントへの参照
- `tags`（任意）  
  - 検索用のタグ（文字列配列）

### 4.3 kind の種類と定義（v1）

v1では、`kind` に次の 6 種類を定義する：

- `purpose`  
  - 何を実現したいか（目的・意図・価値）
- `expected_state`  
  - こうなっていてほしい状態（達成条件・DoD）
- `actual_state`  
  - 実際に観測された状態
- `constraint`  
  - 制約（超えてはいけない条件）
- `assumption`  
  - 前提（そうだと仮定している条件）
- `decision`  
  - 意思決定（いつ何を決めたか）

将来的な追加候補（v2以降で検討）：

- `plan` / `action`  
  - 「決めたこと」と「やる手順」を分けたいときに使う可能性がある。
- `signal` / `observation`  
  - ログ1発のようなイベントと、「状態スナップショット」を分けたいときに使う可能性がある。

ただし v1 では、上記はすべて

- `decision` + `expected_state`
- `actual_state` + `evidence_refs` + `created_at`

の組み合わせで表現できるため、**kind は 6種類に絞る**。

### 4.4 不変条件（v1ルール）

- **1ノード = 1 subject × 1 kind × 1文**

  - `statement` は、単独で読んでも意味がわかる 1 文にする。
  - 複数の意味を詰め込みすぎない（分割できるならノードを分ける）。

- 意味のある分割（どのプロジェクト / フェーズ / レーン / スコープに属するか）は、
  **ファイル名やディレクトリではなく、フィールド（project_id / phase / lane / scope / tags）で表現する。**

---

## 5. info_relation v1

### 5.1 役割

`info_relation` は、2つの `info_node` のあいだの **関係（因果・階層・依存）** を表す。

### 5.2 フィールド一覧

- `id`  
  - 関係を一意に識別するID
- `type`  
  - 関係の種類（後述）
- `from`  
  - 関係の起点となる `info_node.id`
- `to`  
  - 関係の終点となる `info_node.id`
- `note`（任意）  
  - 関係の補足説明

### 5.3 type の種類と定義（v1）

v1では、代表的な 4 種を用意する：

- `refines`  
  - 上位の目的/期待を、より具体的な目的/期待に分解する。

- `supports`  
  - 上位の目的/期待の達成に「寄与する」（あれば嬉しい・進みやすくなる）。

- `blocks`  
  - 満たされていないと、上位の目的/期待を達成できない（ボトルネック）。

- `depends_on`  
  - 実務上の依存関係（順序・手続き・前提条件）。

### 5.4 不変条件（v1ルール）

- `from` / `to` は、必ず既存の `info_node.id` を指す。
- グラフ全体として、**循環しない構造（DAG）** を目指す。
- `type` ごとの意味は、上記の定義に収まるように使う。

---

## 6. 分割と所属（scope / phase / lane）

### 6.1 「スコープ」とは何か

- **scope**  
  = 人間が「ここをひとかたまりとして扱いたい」と決めた、現実の視野・範囲。

  - 例: `"phase2-p2-2-hello"`  
    → Phase 2 の中でも、P2-2: Hello KService READY=True の範囲。

scope は、

- Project の「切り取り方」の一部であり、
- info_node 側では `scope` フィールドとして表現される。

### 6.2 意味を持つ分割はフィールドで表す

意味のある分割は、すべて info_node / info_relation のフィールドで表現する：

- `project_id`
- `phase`
- `lane`
- `scope`
- `tags`

ファイル構造（`data/info_network_v1/*.yml`）は、あくまで

> **「どのノードをどのファイルに梱包しておくか」という便宜的な単位**

として扱い、意味の本体にはしない。

- 推奨：1 scope ≒ 1 ファイルに寄せておくと、人間にも扱いやすい。
- ただし必須ではない。ファイルを分け直しても、フィールドが正しければ意味は保たれる。

---

## 7. VPMエンジンと info_network の関係

- **VPMエンジン**  
  - info_network のモデル（本ドキュメント）を理解し、
  - `info_node` / `info_relation` を読んで考え、更新できるロール群（Kai / Aya / Sho など）の集合。

- **プロジェクトデータ**  
  - `data/info_network_v1/*.yml` に保存された、各 `project_id` ごとの info_network。

vpm-mini の場合：

- `project_id: "vpm-mini"` は  
  → 「VPMエンジンを作る」プロジェクトそのもの。
- その状態を info_network に載せたものが  
  → `data/info_network_v1/...` に入る。

つまり、

- **エンジン（仕組み）** と
- **その仕組みの中で管理される 1 つのプロジェクト（vpm-mini）**

を混同せず、別レイヤーとして扱う。

---

## 8. v1 の運用スコープ（何をやるか / やらないか）

v1 では、次のような割り切りを置く：

- **やること（v1のゴール）**
  - 人間＋Codexが集めた素材（STATE / reports / issue / PR / ログなど）から、
    - Aya / Kai が **info_node / info_relation を生成できるようにする**。
  - 特に、
    - `project_id: "vpm-mini"`, `scope: "phase2-p2-2-hello"`  
      の info_network を最初のサンプルとして整備する。

- **まだやらないこと（v1の外側）**
  - ログの完全自動クロールや、外部システムからの直収。
  - 全プロジェクト・全レーンの info_network 化。
