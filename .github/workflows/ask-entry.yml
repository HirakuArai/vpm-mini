name: ask-entry

on:
  repository_dispatch:
  workflow_dispatch:
  issue_comment:
    types: [created]
  issues:
    types: [opened]

# 保存PRやコメントを書けるように最初に明示
permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read

concurrency:
  group: ask-${{ github.ref }}
  cancel-in-progress: false

jobs:
  ask:
    # 起動条件：issue_comment か workflow/rep dispatch、
    # もしくは issues.opened かつ labels に "ask" が含まれるとき
    if: >
      github.event_name == 'issue_comment' ||
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'repository_dispatch' ||
      (github.event_name == 'issues' && contains(toJson(github.event.issue.labels), '"name":"ask"'))
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Build prompt
        run: |
          set -euo pipefail
          mkdir -p out reports/ask
          ISSUE_BODY="${{ github.event_name == 'issue_comment' && github.event.comment.body || github.event.issue.body }}"
          printf '%s\n' "$(cat tools/prompts/llm_relay_system.md)" > out/sys.txt
          printf 'context_header: repo=vpm-mini / branch=main / phase=Phase 2\n' > out/ctx.txt
          printf 'QUESTION\n%s\n' "$(echo "$ISSUE_BODY")" >> out/ctx.txt

      - name: Call OpenAI (gpt-5; raw & strip fences)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
        run: |
          set -euo pipefail
          jq -n --arg sys "$(cat out/sys.txt)" --arg usr "$(cat out/ctx.txt)" '{
            model:"gpt-5",
            response_format:{type:"json_object"},
            messages:[{role:"system",content:$sys},{role:"user",content:$usr}]
          }' > out/req.json

          curl -sS https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -H "Content-Type: application/json" \
            -d @out/req.json \
            | tee out/raw.json >/dev/null || true

          jq -r '.choices[0].message.content // ""' out/raw.json > out/u_contract.txt

          if [ ! -s out/u_contract.txt ]; then
            # フォールバック（最小スキーマ）
            CH="$(sed -n '1s/^context_header: //p' out/ctx.txt)"
            jq -n --arg ch "$CH" '{
              typing:"no-content",
              context_header:$ch,
              understanding:{C:"",G:"",delta:"",assumptions:[],unknowns:[]},
              plan:[],acceptance:[],citations:[],confidence:0.0
            }' > out/u_contract.json
          else
            # ```json … ``` のフェンス除去
            awk 'NR==1{sub(/^```(json)?[[:space:]]*/,"")} {buf=buf $0 ORS} END{ sub(/```[[:space:]]*[\r\n]*$/,"",buf); printf "%s", buf }' \
              out/u_contract.txt > out/u_contract.json
          fi

      - name: Normalize + Coerce (minimal schema)
        run: |
          set -euo pipefail
          CH=$(sed -n '1s/^context_header: //p' out/ctx.txt)
          jq --arg ch "$CH" '
            (.context_header //= $ch)
            | (.typing //= "plan要約")
            | (.confidence //= 0.5)
            | (.understanding //= {})
            | (.understanding.C //= "")
            | (.understanding.G //= "")
            | (.understanding.delta //= "")
            | (.understanding.assumptions //= [])
            | (.understanding.unknowns //= [])
            | (.plan |= ( if type=="string" then
                            [ {id:"p1", desc:., commands:[], evidence:[], risks:[]} ]
                          elif type=="array" then
                            [ range(0; length) as $i | .[$i]
                              | ( if type=="string"
                                    then {id:("p"+(($i+1)|tostring)), desc:., commands:[], evidence:[], risks:[]}
                                    elif type=="object" then . else . end ) ]
                          else [] end ))
            | (.acceptance |= ( if type=="string" then [.] elif type=="array" then . else [] end ))
            | (.citations |= ( if type=="string" then [ {path:., lines:\"\"} ]
                               elif type=="array" then [ .[] | ( if type=="string" then {path:., lines:\"\"} else . end ) ]
                               elif type=="object" then [.] else [] end ))
          ' out/u_contract.json > out/u_contract.norm.json
          mv out/u_contract.norm.json out/u_contract.json

      - name: Comment back JSON (always)
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          ISSUE_NUMBER: ${{ github.event.issue.number || github.event.pull_request.number }}
        run: |
          set -euo pipefail
          BODY="$(printf '%s\n%s\n%s\n' '```json' "$(cat out/u_contract.json)" '```')"
          gh api "repos/${REPO}/issues/${ISSUE_NUMBER}/comments" -f body="$BODY"

      - name: Open Save-PR (always)
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          ts=$(date -u +%Y%m%dT%H%M%SZ)
          mkdir -p reports/ask
          cp out/u_contract.json "reports/ask/ask_${ts}.json"

          git config user.email "bot@users.noreply.github.com"
          git config user.name  "github-actions[bot]"

          BR="ask/store/${ts}"
          git checkout -b "$BR"
          git add "reports/ask/ask_${ts}.json"
          git commit -m "ask: persist u_contract (${ts})"
          git push -u origin "$BR"

          gh pr create --base main --head "$BR" \
            -t "ask: persist u_contract (${ts})" \
            -b "Persisted from ask-entry." \
            --label ask --label evidence || true
