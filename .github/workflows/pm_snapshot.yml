name: PM Snapshot (Gen, vpm-mini)

on:
  workflow_dispatch:
    inputs:
      project_id:
        description: "Target project_id (e.g. vpm-mini)"
        required: false
        default: "vpm-mini"
      as_of_date:
        description: "Snapshot date in JST (YYYY-MM-DD)"
        required: false
        default: ""
      use_blackboard:
        description: "If true, allow blackboard-driven runs; when false, as_of_date must be provided."
        required: false
        default: "true"
  push:
    paths:
      - ".github/workflows/pm_snapshot.yml"
  pull_request:
    paths:
      - ".github/workflows/pm_snapshot.yml"

jobs:
  snapshot:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      issues: write
    env:
      BOARD_ISSUE_NUMBER: "841" # [board] doc_update_blackboard_v1 (Issue #841)
      PROJECT_ID: ${{ github.event.inputs.project_id || 'vpm-mini' }}

    steps:
      - uses: actions/checkout@v4

      - name: Resolve snapshot date
        id: resolve_snapshot_date
        run: |
          set -euo pipefail
          USE_BLACKBOARD="${{ github.event.inputs.use_blackboard }}"
          SNAPSHOT_DATE="${{ github.event.inputs.as_of_date }}"

          if [ "${USE_BLACKBOARD}" != "false" ] && [ -z "${SNAPSHOT_DATE}" ]; then
            SNAPSHOT_DATE=$(TZ=Asia/Tokyo date +%Y-%m-%d)
            echo "as_of_date was empty; blackboard mode active, using JST today: ${SNAPSHOT_DATE}"
          fi

          if [ "${USE_BLACKBOARD}" = "false" ] && [ -z "${SNAPSHOT_DATE}" ]; then
            echo "as_of_date is required when use_blackboard is false." >&2
            exit 1
          fi

          echo "as_of_date=${SNAPSHOT_DATE}" >> "$GITHUB_OUTPUT"
      - name: Find Gen entry from blackboard
        id: find_gen_entry
        if: ${{ github.event.inputs.use_blackboard != 'false' }}
        uses: actions/github-script@v7
        env:
          BOARD_ISSUE_NUMBER: ${{ env.BOARD_ISSUE_NUMBER }}
          PROJECT_ID: ${{ env.PROJECT_ID }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = parseInt(process.env.BOARD_ISSUE_NUMBER, 10);
            const projectId = process.env.PROJECT_ID;

            if (!issueNumber) {
              core.setFailed("BOARD_ISSUE_NUMBER is not set or invalid.");
              return;
            }
            if (!projectId) {
              core.setFailed("PROJECT_ID is required.");
              return;
            }

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              per_page: 100,
            });

            const candidates = [];
            for (const comment of comments) {
              const body = comment.body || "";
              if (!body.includes("<!-- blackboard:doc_update_v1 -->")) {
                continue;
              }
              const fenceMatch = body.match(/```json\s*([\s\S]*?)```/m);
              const inlineMatch = body.match(/json\s+({[\s\S]*})/m);
              const jsonText = fenceMatch?.[1] ?? inlineMatch?.[1];
              if (!jsonText) continue;

              let entry;
              try {
                entry = JSON.parse(jsonText);
              } catch (error) {
                core.info(`Skipping comment ${comment.id}: failed to parse JSON (${error}).`);
                continue;
              }

              if (
                entry?.to === "Gen" &&
                entry?.kind === "pm_snapshot_request" &&
                entry?.status === "open" &&
                entry?.project_id === projectId
              ) {
                const createdAt =
                  entry.created_at ||
                  entry.ts ||
                  comment.created_at ||
                  comment.createdAt ||
                  comment.updated_at;
                const ts =
                  Date.parse(entry.created_at || "") ||
                  Date.parse(entry.ts || "") ||
                  Number(entry.ts) ||
                  Date.parse(createdAt) ||
                  0;
                candidates.push({ entry, ts, comment });
              }
            }

            if (!candidates.length) {
              core.setFailed("No open pm_snapshot_request to Gen found on the blackboard.");
              return;
            }

            candidates.sort((a, b) => a.ts - b.ts);
            const oldest = candidates[0];
            core.info(`Selected Gen entry with id: ${oldest.entry.id || "unknown"}`);
            core.setOutput("gen_entry", JSON.stringify(oldest.entry));
            core.setOutput("comment_id", String(oldest.comment?.id || oldest.entry?.source_comment_id || ""));
            core.setOutput("issue_number", String(issueNumber));

      - name: Gather context files
        shell: bash
        env:
          RESOLVED_AS_OF_DATE: ${{ steps.resolve_snapshot_date.outputs.as_of_date }}
        run: |
          set -euo pipefail
          PROJECT_ID="${{ github.event.inputs.project_id }}"
          AS_OF_DATE="${RESOLVED_AS_OF_DATE}"
          if [ -z "${AS_OF_DATE:-}" ]; then
            echo "as_of_date is required (YYYY-MM-DD, JST)" >&2
            exit 1
          fi
          mkdir -p /tmp/pm-context
          cp "docs/projects/${PROJECT_ID}/project_definition.md" /tmp/pm-context/project_definition.md
          cp "STATE/${PROJECT_ID}/current_state.md" /tmp/pm-context/current_state.md
          latest_weekly=$(ls -1 "reports/${PROJECT_ID}"/*_weekly.md | sort | tail -n 1)
          cp "$latest_weekly" /tmp/pm-context/weekly.md
          cp "docs/pm/pm_snapshot_v1_spec.md" /tmp/pm-context/spec.md

      - name: Build PM snapshot prompt
        shell: bash
        env:
          PROJECT_ID: ${{ github.event.inputs.project_id }}
          AS_OF_DATE: ${{ steps.resolve_snapshot_date.outputs.as_of_date }}
        run: |
          set -euo pipefail
          if [ -z "${AS_OF_DATE:-}" ]; then
            echo "AS_OF_DATE is required (YYYY-MM-DD, JST)" >&2
            exit 1
          fi
          cd /tmp/pm-context
          python - << 'PY'
          import os
          import pathlib
          import textwrap

          base = pathlib.Path(".")
          proj_def = (base / "project_definition.md").read_text(encoding="utf-8")
          state = (base / "current_state.md").read_text(encoding="utf-8")
          weekly = (base / "weekly.md").read_text(encoding="utf-8")
          spec = (base / "spec.md").read_text(encoding="utf-8")
          project_id = os.environ.get("PROJECT_ID", "vpm-mini")
          as_of_date = os.environ["AS_OF_DATE"]

          prompt = f"""
          あなたは Virtual Project Manager (PM Kai v1) です。
          対象プロジェクト: {project_id}
          対象日付 (as_of_date, JST): {as_of_date}

          以下の仕様にしたがって、as_of_date={as_of_date} (JST) の状況をもとに、pm_snapshot_v1 JSON とその要約の Markdown ビューを「レビュー用スナップショット」として生成してください。この Workflow 自体は STATE や weekly レポートを直接更新しません。

          === 出力仕様 (docs/pm/pm_snapshot_v1_spec.md) ===
          {spec}

          === project_definition (docs/projects/{project_id}/project_definition.md) ===
          {proj_def}

          === STATE/current_state (STATE/{project_id}/current_state.md) ===
          {state}

          === latest weekly report ===
          {weekly}

          手順:
          1) まず pm_snapshot_v1 JSON を出力する
          2) その直後の行に '---' を 1 行だけ出力する
          3) 続けて Markdown ビューを出力する
          4) Markdown 冒頭かメタ情報に as_of_date: {as_of_date} (JST) を明記する
          """.strip()

          out = base / "prompt.txt"
          out.write_text(prompt, encoding="utf-8")
          print(f"wrote prompt to {out}")
          PY

      - name: Call OpenAI for PM snapshot (gpt-5; strip fences)
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          PROJECT_ID: ${{ github.event.inputs.project_id }}
          AS_OF_DATE: ${{ steps.resolve_snapshot_date.outputs.as_of_date }}
        run: |
          set -euo pipefail
          if [ -z "${AS_OF_DATE:-}" ]; then
            echo "AS_OF_DATE is required (YYYY-MM-DD, JST)" >&2
            exit 1
          fi
          mkdir -p reports/pm_snapshots
          prompt="$(cat /tmp/pm-context/prompt.txt)"

          jq -n --arg sys "You are PM Kai v1. Follow the user prompt to produce a pm_snapshot_v1 JSON snapshot and then '---' and a Markdown view for review. Your job is only to describe the current C/G/δ and candidate Next actions; you do not directly update STATE or weekly reports. Your output is used later by humans and the Aya/Sho/doc_update lane to decide and reflect actual changes." \
                --arg usr "$prompt" '{
            model:"gpt-5",
            messages:[{role:"system",content:$sys},{role:"user",content:$usr}]
          }' > /tmp/pm-context/req.json

          curl -sS https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -H "Content-Type: application/json" \
            -d @/tmp/pm-context/req.json \
            | tee /tmp/pm-context/raw.json >/dev/null || true

          jq -r '.choices[0].message.content // ""' /tmp/pm-context/raw.json > /tmp/pm-context/pm_snapshot.txt

          # Strip outer fences if the model wrapped the whole response
          awk 'NR==1{sub(/^```[a-zA-Z0-9_-]*[[:space:]]*/,"")} {buf=buf $0 ORS} END{sub(/```[[:space:]]*[\r\n]*$/,"",buf); printf "%s", buf}' \
            /tmp/pm-context/pm_snapshot.txt > /tmp/pm-context/pm_snapshot.clean.txt

          SNAP_OUT="reports/pm_snapshots/${AS_OF_DATE}_${PROJECT_ID}.md"
          cp /tmp/pm-context/pm_snapshot.clean.txt "$SNAP_OUT"

          echo "Saved snapshot to $SNAP_OUT"
          head -n 20 "$SNAP_OUT" || true

      - name: Upload PM snapshot artifact
        uses: actions/upload-artifact@v4
        with:
          name: pm_snapshot-${{ github.event.inputs.project_id || 'vpm-mini' }}
          path: reports/pm_snapshots/${{ steps.resolve_snapshot_date.outputs.as_of_date }}_${{ github.event.inputs.project_id || 'vpm-mini' }}.md

      - name: Mark Gen pm_snapshot_request as done on blackboard
        if: ${{ success() && steps.find_gen_entry.outputs.gen_entry != '' }}
        uses: actions/github-script@v7
        env:
          GEN_ENTRY: ${{ steps.find_gen_entry.outputs.gen_entry }}
          COMMENT_ID: ${{ steps.find_gen_entry.outputs.comment_id }}
          ISSUE_NUMBER: ${{ steps.find_gen_entry.outputs.issue_number }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const entry = JSON.parse(process.env.GEN_ENTRY || "{}");
            const commentId = parseInt(process.env.COMMENT_ID || "", 10);
            const issueNumber = parseInt(process.env.ISSUE_NUMBER || "", 10);
            if (!commentId || Number.isNaN(commentId)) {
              core.setFailed("comment_id is missing; cannot update blackboard entry.");
              return;
            }
            if (!issueNumber || Number.isNaN(issueNumber)) {
              core.setFailed("issue_number is missing; cannot update blackboard entry.");
              return;
            }

            const jstIso = () => {
              const now = new Date();
              const jst = new Date(now.getTime() + 9 * 60 * 60 * 1000);
              return jst.toISOString().replace(/Z$/, "+09:00");
            };
            entry.status = "done";
            entry.updated_at = jstIso();

            const body = [
              "<!-- blackboard:doc_update_v1 -->",
              "",
              "json",
              JSON.stringify(entry, null, 2),
            ].join("\n");

            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body,
            });

            core.info(`Updated Gen pm_snapshot_request comment ${commentId} on issue ${issueNumber} to status=done`);

      - name: Add Gen→Hana pm_snapshot_done blackboard comment
        if: ${{ success() && steps.find_gen_entry.outputs.gen_entry != '' }}
        uses: actions/github-script@v7
        env:
          GEN_ENTRY: ${{ steps.find_gen_entry.outputs.gen_entry }}
          ISSUE_NUMBER: ${{ steps.find_gen_entry.outputs.issue_number }}
          RESOLVED_AS_OF_DATE: ${{ steps.resolve_snapshot_date.outputs.as_of_date }}
          PROJECT_ID: ${{ env.PROJECT_ID }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const entry = JSON.parse(process.env.GEN_ENTRY || "{}");
            const issueNumber = parseInt(process.env.ISSUE_NUMBER || "", 10);
            const projectId = entry.project_id || process.env.PROJECT_ID || "vpm-mini";
            const asOfDate = process.env.RESOLVED_AS_OF_DATE || "";
            if (!issueNumber || Number.isNaN(issueNumber)) {
              core.setFailed("issue_number is missing; cannot add pm_snapshot_done comment.");
              return;
            }
            if (!asOfDate) {
              core.setFailed("as_of_date is missing; cannot build pm_snapshot_done card.");
              return;
            }

            const jstIso = () => {
              const now = new Date();
              const jst = new Date(now.getTime() + 9 * 60 * 60 * 1000);
              return jst.toISOString().replace(/Z$/, "+09:00");
            };

            const snapshotPath = `reports/pm_snapshots/${asOfDate}_${projectId}.md`;
            const nowTs = jstIso();
            const card = {
              id: `${entry.id || "pm_snapshot"}-done`,
              from: "Gen",
              to: "Hana",
              project_id: projectId,
              kind: "pm_snapshot_done",
              status: "open",
              payload: {
                summary:
                  (entry.payload && entry.payload.summary) ||
                  `pm_snapshot completed for cycle ${entry.id || "unknown"}`,
                refs: {
                  snapshot_file_path: snapshotPath,
                  snapshot_as_of_date: asOfDate,
                  pm_snapshot_workflow_run_id: process.env.GITHUB_RUN_ID,
                  source_board_id: entry.id || "",
                },
              },
              target_docs: Array.isArray(entry.target_docs) ? entry.target_docs : [],
              created_at: nowTs,
              updated_at: nowTs,
            };

            const body = [
              "<!-- blackboard:doc_update_v1 -->",
              "",
              "json",
              JSON.stringify(card, null, 2),
            ].join("\n");

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body,
            });

            core.info(`Posted pm_snapshot_done card for entry ${entry.id || "unknown"} to Hana on issue ${issueNumber}`);
