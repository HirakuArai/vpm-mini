# cell_roles: watcher, curator, planner, synthesizer

name: Doc Update Review (Sho)

on:
  workflow_dispatch:
    inputs:
      project_id:
        description: "Target project_id (e.g. vpm-mini, hakone-e2)"
        required: true
        default: "vpm-mini"

jobs:
  review:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
      issues: write
    env:
      BOARD_ISSUE_NUMBER: "841" # [board] doc_update_blackboard_v1 (Issue #841)
      PROJECT_ID: ${{ github.event.inputs.project_id }}
    steps:
      - uses: actions/checkout@v4

      - name: Find Sho entry from blackboard
        id: find_sho_entry
        uses: actions/github-script@v7
        env:
          BOARD_ISSUE_NUMBER: ${{ env.BOARD_ISSUE_NUMBER }}
          PROJECT_ID: ${{ env.PROJECT_ID }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = parseInt(process.env.BOARD_ISSUE_NUMBER, 10);
            const projectId = process.env.PROJECT_ID;

            if (!issueNumber) {
              core.setFailed("BOARD_ISSUE_NUMBER is not set or invalid.");
              return;
            }
            if (!projectId) {
              core.setFailed("PROJECT_ID is required.");
              return;
            }

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              per_page: 100,
            });

            const candidates = [];
            for (const comment of comments) {
              const body = comment.body || "";
              if (!body.includes("<!-- blackboard:doc_update_v1 -->")) {
                continue;
              }
              const fenceMatch = body.match(/```json\s*([\s\S]*?)```/m);
              const inlineMatch = body.match(/json\s+({[\s\S]*})/m);
              const jsonText = fenceMatch?.[1] ?? inlineMatch?.[1];
              if (!jsonText) continue;

              let entry;
              try {
                entry = JSON.parse(jsonText);
              } catch (error) {
                core.info(`Skipping comment ${comment.id}: failed to parse JSON (${error}).`);
                continue;
              }

              if (
                entry?.to === "Sho" &&
                entry?.from === "Aya" &&
                entry?.kind === "doc_update_review_request" &&
                entry?.status === "open" &&
                entry?.project_id === projectId
              ) {
                const createdAt =
                  entry.created_at ||
                  comment.created_at ||
                  comment.createdAt ||
                  comment.updated_at;
                const ts = Date.parse(createdAt) || 0;
                candidates.push({ entry, ts, comment });
              }
            }

            if (!candidates.length) {
              core.setFailed("No open doc_update_review_request to Sho found on the blackboard.");
              return;
            }

            candidates.sort((a, b) => a.ts - b.ts);
            const oldest = candidates[0];
            core.info(`Selected Sho entry with id: ${oldest.entry.id || "unknown"}`);
            core.setOutput("sho_entry", JSON.stringify(oldest.entry));
            core.setOutput("comment_id", String(oldest.comment?.id || oldest.entry?.source_comment_id || ""));
            core.setOutput("issue_number", String(issueNumber));

      - name: Download doc update proposal artifact
        id: download_proposal
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          printf '%s' '${{ steps.find_sho_entry.outputs.sho_entry }}' > sho_entry.json

          ARTIFACT_NAME=$(jq -r '.payload_ref.artifact_name // empty' sho_entry.json)
          RUN_ID=$(jq -r '.payload_ref.workflow_run_id // empty' sho_entry.json)

          if [ -z "$ARTIFACT_NAME" ] || [ -z "$RUN_ID" ]; then
            echo "Missing artifact reference in Sho entry."
            exit 1
          fi

          echo "Downloading artifact ${ARTIFACT_NAME} from run ${RUN_ID}..."
          gh run download "$RUN_ID" -n "$ARTIFACT_NAME"

          if [ -f doc_update_proposal_v1.json ]; then
            PROPOSAL_PATH="doc_update_proposal_v1.json"
          else
            PROPOSAL_PATH=$(find . -maxdepth 3 -name 'doc_update_proposal_v1.json' | head -n1 || true)
          fi

          if [ -z "$PROPOSAL_PATH" ]; then
            echo "doc_update_proposal_v1.json not found in downloaded artifact."
            ls -R .
            exit 1
          fi

          echo "Using proposal at $PROPOSAL_PATH"
          echo "proposal_path=$PROPOSAL_PATH" >> "$GITHUB_OUTPUT"

      - name: Generate doc update review (auto-accept v1)
        id: generate_review
        env:
          PROPOSAL_PATH: ${{ steps.download_proposal.outputs.proposal_path }}
          # pragma: allowlist secret
          OPENAI_API_KEY_REVIEW: ${{ secrets.OPENAI_API_KEY }} # pragma: allowlist secret
        run: | # pragma: allowlist secret
          set -euo pipefail

          python - << 'PY'
          import datetime
          import json
          import os
          import pathlib
          import sys
          import urllib.request

          proposal_path = pathlib.Path(os.environ.get("PROPOSAL_PATH") or "doc_update_proposal_v1.json")
          api_key = os.environ.get("OPENAI_API_KEY_REVIEW")
          if not proposal_path.exists():
            print(f"Proposal JSON not found: {proposal_path}", file=sys.stderr)
            sys.exit(1)
          if not api_key:
            print("OPENAI_API_KEY is required for Sho review", file=sys.stderr)
            sys.exit(1)

          proposal = json.loads(proposal_path.read_text(encoding="utf-8"))

          def call_openai(system: str, user: str) -> str:
            payload = {
              "model": "gpt-4o",
              "messages": [
                {"role": "system", "content": system},
                {"role": "user", "content": user},
              ],
              "temperature": 0.2,
              "max_tokens": 2000,
            }
            data = json.dumps(payload).encode("utf-8")
            req = urllib.request.Request(
              "https://api.openai.com/v1/chat/completions",
              data=data,
              headers={
                "Content-Type": "application/json",
                "Authorization": f"Bearer {api_key}",
              },
            )
            with urllib.request.urlopen(req, timeout=90) as resp:
              body = resp.read().decode("utf-8")
            try:
              return json.loads(body)["choices"][0]["message"]["content"]
            except Exception as exc:  # noqa: BLE001
              print(f"OpenAI response parse error: {body}", file=sys.stderr)
              raise exc

          updates = proposal.get("updates", [])
          per_path = {}
          for u in updates:
            target = u.get("target", {}) or {}
            path = target.get("path") or u.get("target_path")
            if not path:
              print("Skipping update without target path", file=sys.stderr)
              continue

            current_content = ""
            file_path = pathlib.Path(path)
            if file_path.exists():
              current_content = file_path.read_text(encoding="utf-8")

            suggestion = (
              u.get("final_content")
              or u.get("suggestion_markdown")
              or target.get("after")
              or ""
            )
            notes = u.get("reason") or ""

            system_prompt = (
              "You are Sho (Doc Update Review). Given the current file and Aya's proposal snippet, "
              "produce the complete updated file content. Preserve headings and unrelated sections unless change is implied. "
              "Return only the full updated file text; no JSON or fences."
            )
            user_prompt = (
              f"target_path: {path}\n"
              f"current_file:\n{current_content}\n\n"
              f"proposal_snippet:\n{suggestion}\n\n"
              f"notes:\n{notes}\n\n"
              "Write the full updated file content reflecting the proposal and notes. Keep structure, only adjust what is needed."
            )

            final_content = call_openai(system_prompt, user_prompt).strip()

            ru = dict(u)
            ru["status"] = "accept"
            ru["risk"] = "low"
            ru["reviewer_comment"] = "v1 auto-accept by Sho; human review still recommended."
            ru["change_type"] = "replace_whole_file"
            ru["final_content"] = final_content or current_content

            # ensure one entry per path (latest wins if duplicates)
            ru["target"] = {"path": path, **{k: v for k, v in target.items() if k != "path"}}
            per_path[path] = ru

          review_updates = list(per_path.values())

          review = {
            "schema_version": "doc_update_review_v1",
            "project_id": proposal.get("project_id", ""),
            "generated_at": datetime.datetime.now(datetime.timezone.utc).isoformat(),
            "decision": "auto_accept_all",
            "review_mode": "auto_accept_v1",
            "updates": review_updates,
            "no_change": proposal.get("no_change", []),
            "notes": [
              "Auto-generated Sho v1 review: accepts all updates; please double-check manually."
            ],
          }

          out = pathlib.Path("doc_update_review_v1.json")
          out.write_text(json.dumps(review, ensure_ascii=False, indent=2), encoding="utf-8")
          print(f"Wrote {out}")
          PY

          echo "review_path=doc_update_review_v1.json" >> "$GITHUB_OUTPUT"

      - name: Upload doc update review artifact
        uses: actions/upload-artifact@v4
        with:
          name: doc_update_review_v1_${{ github.run_id }}
          path: doc_update_review_v1.json
          retention-days: 14

      - name: Mark Sho review_request as done on blackboard
        uses: actions/github-script@v7
        env:
          SHO_ENTRY: ${{ steps.find_sho_entry.outputs.sho_entry }}
          COMMENT_ID: ${{ steps.find_sho_entry.outputs.comment_id }}
          ISSUE_NUMBER: ${{ steps.find_sho_entry.outputs.issue_number }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const entry = JSON.parse(process.env.SHO_ENTRY || "{}");
            const commentId = parseInt(process.env.COMMENT_ID || "", 10);
            const issueNumber = parseInt(process.env.ISSUE_NUMBER || "", 10);
            if (!commentId || Number.isNaN(commentId)) {
              core.setFailed("comment_id is missing; cannot update blackboard entry.");
              return;
            }
            if (!issueNumber || Number.isNaN(issueNumber)) {
              core.setFailed("issue_number is missing; cannot update blackboard entry.");
              return;
            }

            const now = new Date().toISOString();
            entry.status = "done";
            entry.updated_at = now;

            const body = [
              "<!-- blackboard:doc_update_v1 -->",
              "",
              "json",
              JSON.stringify(entry, null, 2),
            ].join("\n");

            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body,
            });

            core.info(`Updated Sho review_request comment ${commentId} on issue ${issueNumber} to status=done`);

      - name: Add Sho→Tsugu apply_request blackboard comment
        uses: actions/github-script@v7
        env:
          SHO_ENTRY: ${{ steps.find_sho_entry.outputs.sho_entry }}
          ISSUE_NUMBER: ${{ steps.find_sho_entry.outputs.issue_number }}
          PROJECT_ID: ${{ env.PROJECT_ID }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = parseInt(process.env.ISSUE_NUMBER || "", 10);
            if (!issueNumber || Number.isNaN(issueNumber)) {
              core.setFailed("issue_number is missing; cannot post Sho→Tsugu apply_request.");
              return;
            }

            const requestEntry = JSON.parse(process.env.SHO_ENTRY || "{}");
            const requestId = requestEntry.id || `doc-update-${context.runId}`;
            const now = new Date().toISOString();

            const targetDocs = Array.isArray(requestEntry.target_docs) ? requestEntry.target_docs : [];
            const payloadRefs = (requestEntry.payload && requestEntry.payload.refs) || {};
            const proposalArtifactName =
              payloadRefs.proposal_artifact_name ||
              (requestEntry.payload_ref && requestEntry.payload_ref.artifact_name) ||
              "";
            const proposalRunId =
              payloadRefs.proposal_workflow_run_id ||
              (requestEntry.payload_ref && requestEntry.payload_ref.workflow_run_id) ||
              "";
            const summary =
              (requestEntry.payload && typeof requestEntry.payload.summary === "string" && requestEntry.payload.summary) ||
              `Apply request based on review ${requestId}`;

            const entry = {
              id: `${requestId}-apply`,
              from: "Sho",
              to: "Tsugu",
              project_id: process.env.PROJECT_ID,
              kind: "doc_update_apply_request",
              status: "open",
              payload: {
                summary,
                refs: {
                  proposal_artifact_name: proposalArtifactName,
                  proposal_workflow_run_id: proposalRunId,
                  review_artifact_name: `doc_update_review_v1_${context.runId}`,
                  review_workflow_run_id: context.runId,
                  source_board_id: requestId,
                },
              },
              target_docs: targetDocs,
              created_at: now,
              updated_at: now,
            };

            const body = [
              "<!-- blackboard:doc_update_v1 -->",
              "",
              "json",
              JSON.stringify(entry, null, 2),
            ].join("\n");

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body,
            });

            core.info(`Posted Sho→Tsugu apply_request entry with id ${entry.id} on issue ${issueNumber}`);

      - name: Add Sho→Aya blackboard comment
        uses: actions/github-script@v7
        env:
          BOARD_ISSUE_NUMBER: ${{ env.BOARD_ISSUE_NUMBER }}
          PROJECT_ID: ${{ env.PROJECT_ID }}
          SHO_ENTRY: ${{ steps.find_sho_entry.outputs.sho_entry }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = parseInt(process.env.BOARD_ISSUE_NUMBER, 10);
            const projectId = process.env.PROJECT_ID;
            const shoEntry = JSON.parse(process.env.SHO_ENTRY || "{}");
            if (!issueNumber) {
              core.setFailed("BOARD_ISSUE_NUMBER is not set or invalid.");
              return;
            }
            if (!projectId) {
              core.setFailed("PROJECT_ID is required.");
              return;
            }
            const inReplyTo = shoEntry.id;

            const now = new Date();
            const id = `${now.toISOString()}_${projectId}_shotoaya_${context.runId}`;
            const payloadRef = {
              type: "actions_artifact",
              workflow_run_id: context.runId,
              artifact_name: `doc_update_review_v1_${context.runId}`,
            };

            const entry = {
              id,
              from: "Sho",
              to: "Aya",
              project_id: projectId,
              kind: "doc_update_review_result",
              payload_ref: payloadRef,
              in_reply_to: inReplyTo,
              status: "done",
              created_at: now.toISOString(),
            };

            const body = [
              "<!-- blackboard:doc_update_v1 -->",
              "",
              "json",
              JSON.stringify(entry, null, 2),
            ].join("\n");

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body,
            });

            core.info(`Posted Sho→Aya blackboard comment with id: ${id}`);
