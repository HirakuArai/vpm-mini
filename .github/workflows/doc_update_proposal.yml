# cell_roles: watcher, curator, planner, synthesizer

name: Doc Update Proposal (Aya)

on:
  workflow_dispatch:
    # progress_summary is read from blackboard Issue #841; workflow inputs only require project_id
    inputs:
      project_id:
        description: "Target project_id (e.g. vpm-mini, hakone-e2)"
        required: true
        default: "vpm-mini"

jobs:
  propose_updates:
    runs-on: ubuntu-latest
    env:
      BOARD_ISSUE_NUMBER: "841" # [board] doc_update_blackboard_v1 (Issue #841)
      PROJECT_ID: ${{ github.event.inputs.project_id }}
    steps:
      - uses: actions/checkout@v4

      - name: Find Aya entry from blackboard
        id: find_aya_entry
        uses: actions/github-script@v7
        env:
          BOARD_ISSUE_NUMBER: ${{ env.BOARD_ISSUE_NUMBER }}
          PROJECT_ID: ${{ env.PROJECT_ID }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = parseInt(process.env.BOARD_ISSUE_NUMBER, 10);
            const projectId = process.env.PROJECT_ID;

            if (!issueNumber) {
              core.setFailed("BOARD_ISSUE_NUMBER is not set or invalid.");
              return;
            }
            if (!projectId) {
              core.setFailed("PROJECT_ID is required.");
              return;
            }

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              per_page: 100,
            });

            const candidates = [];
            for (const comment of comments) {
              const body = comment.body || "";
              if (!body.includes("<!-- blackboard:doc_update_v1 -->")) {
                continue;
              }
              const fenceMatch = body.match(/```json\s*([\s\S]*?)```/m);
              const inlineMatch = body.match(/json\s+({[\s\S]*})/m);
              const jsonText = fenceMatch?.[1] ?? inlineMatch?.[1];
              if (!jsonText) continue;

              let entry;
              try {
                entry = JSON.parse(jsonText);
              } catch (error) {
                core.info(`Skipping comment ${comment.id}: failed to parse JSON (${error}).`);
                continue;
              }

              if (
                entry?.to === "Aya" &&
                entry?.kind === "doc_update_proposal_request" &&
                entry?.status === "open" &&
                entry?.project_id === projectId
              ) {
                const createdAt =
                  entry.created_at ||
                  comment.created_at ||
                  comment.createdAt ||
                  comment.updated_at;
                const ts = Date.parse(createdAt) || 0;
                candidates.push({ entry, ts, comment });
              }
            }

            if (!candidates.length) {
              core.setFailed("No open doc_update_proposal_request to Aya found on the blackboard.");
              return;
            }

            candidates.sort((a, b) => a.ts - b.ts);
            const oldest = candidates[0];
            core.info(`Selected Aya entry with id: ${oldest.entry.id || "unknown"}`);
            core.setOutput("aya_entry", JSON.stringify(oldest.entry));
            core.setOutput("comment_id", String(oldest.comment?.id || oldest.entry?.source_comment_id || ""));
            core.setOutput("issue_number", String(issueNumber));

      - name: Prepare progress summary from blackboard entry
        id: prepare_progress_summary
        run: |
          set -euo pipefail

          printf '%s' '${{ steps.find_aya_entry.outputs.aya_entry }}' > aya_entry.json

          python - << 'PY'
          import json
          import os
          import pathlib
          import sys

          AYA_ENTRY = pathlib.Path("aya_entry.json")
          SUMMARY_OUT = pathlib.Path("progress_summary.md")

          def load_summary_from_file(path_str: str) -> str:
            """Load summary text from a given path (relative or absolute)."""
            path = pathlib.Path(path_str)
            if not path.is_file():
              raise FileNotFoundError(f"payload_ref.value path not found: {path}")
            return path.read_text(encoding="utf-8")

          def extract_summary(entry: dict) -> str:
            """Doc Update v1 (Aya) summary resolution: prefer payload.summary; fall back to payload_ref.value file content."""
            payload = entry.get("payload") or {}
            summary = payload.get("summary")
            if isinstance(summary, str) and summary.strip():
              return summary

            payload_ref = entry.get("payload_ref") or {}
            ref_value = payload_ref.get("value")
            if isinstance(ref_value, str) and ref_value.strip():
              return load_summary_from_file(ref_value)

            raise ValueError("No payload.summary and no payload_ref.value found in entry")

          def main() -> None:
            entry = json.loads(AYA_ENTRY.read_text(encoding="utf-8"))
            summary_text = extract_summary(entry)
            SUMMARY_OUT.write_text(summary_text, encoding="utf-8")
            print(f"Wrote summary to {SUMMARY_OUT}")

            github_output = os.environ.get("GITHUB_OUTPUT")
            if github_output:
              with open(github_output, "a", encoding="utf-8") as fh:
                fh.write(f"progress_summary_path={SUMMARY_OUT}\n")

          if __name__ == "__main__":
            main()
          PY

      - name: Gather project SSOT files
        run: |
          set -e
          PROJECT_ID="${PROJECT_ID}"
          mkdir -p /tmp/doc-update-context

          # project_definition
          if [ -f "docs/projects/${PROJECT_ID}/project_definition.md" ]; then
            cp "docs/projects/${PROJECT_ID}/project_definition.md" /tmp/doc-update-context/project_definition.md
          fi

          # STATE
          if [ -f "STATE/${PROJECT_ID}/current_state.md" ]; then
            cp "STATE/${PROJECT_ID}/current_state.md" /tmp/doc-update-context/current_state.md
          fi

          # latest weekly (if any)
          if [ -d "reports/${PROJECT_ID}" ]; then
            latest_weekly=$(ls -1 "reports/${PROJECT_ID}"/*_weekly.md 2>/dev/null | sort | tail -n 1 || true)
            if [ -n "$latest_weekly" ]; then
              cp "$latest_weekly" /tmp/doc-update-context/weekly.md
            fi
          fi

          # PM specs
          if [ -f "docs/pm/pm_snapshot_v1_spec.md" ]; then
            cp "docs/pm/pm_snapshot_v1_spec.md" /tmp/doc-update-context/pm_snapshot_v1_spec.md
          fi
          if [ -f "docs/pm/layer_b_update_flow.md" ]; then
            cp "docs/pm/layer_b_update_flow.md" /tmp/doc-update-context/layer_b_update_flow.md
          fi

      - name: Build doc update proposal prompt
        env:
          PROJECT_ID: ${{ env.PROJECT_ID }}
          PROGRESS_SUMMARY_PATH: ${{ steps.prepare_progress_summary.outputs.progress_summary_path }}
        run: |
          set -e
          cd /tmp/doc-update-context

          python - << 'PY'
          import os
          import pathlib
          import textwrap

          base = pathlib.Path(".")

          def read_if_exists(path: str) -> str:
            p = base / path
            return p.read_text(encoding="utf-8") if p.exists() else ""

          def read_progress_summary(path: str) -> str:
            if not path:
              return ""
            p = pathlib.Path(path)
            if p.exists():
              return p.read_text(encoding="utf-8")
            return ""

          project_def = read_if_exists("project_definition.md")
          state = read_if_exists("current_state.md")
          weekly = read_if_exists("weekly.md")
          pm_spec = read_if_exists("pm_snapshot_v1_spec.md")
          layer_b = read_if_exists("layer_b_update_flow.md")
          project_id = os.environ.get("PROJECT_ID", "")
          progress_summary_path = os.environ.get("PROGRESS_SUMMARY_PATH", "")
          progress_summary = read_progress_summary(progress_summary_path)

          schema_desc = textwrap.dedent("""
          あなたは Virtual Project Manager です。
          5セルの観点では、主に Curator（何が重要かを見極める）、Planner（どこに手を入れるか決める）、Synthesizer（人間が読める文章にまとめる）の役割を担っています。

          以下の JSON 形式 doc_update_proposal_v1 で、ドキュメント更新提案を返してください。

          doc_update_proposal_v1 の構造:

          {
            "schema_version": "doc_update_proposal_v1",
            "project_id": "<project_id>",
            "generated_at": "<ISO8601>",

            "summary": "一言サマリ（日本語）",

            "updates": [
              {
                "target": {
                  "path": "STATE/hakone-e2/current_state.md",
                  "doc_type": "state",          // "state" | "weekly" | "project_definition" | "other"
                  "section_hint": "1.1 Current（C）" // どのあたりを変えるかのヒント（見出し名など）
                },
                "reason": "なぜこのドキュメントを更新すべきか（日本語）",
                "change_type": "edit_paragraph",   // "add" | "edit_paragraph" | "append_list_item" | "other"
                "suggestion_markdown": "ここに差し替え後 or 追記候補のMarkdownテキスト",
                "confidence": "high"               // "high" | "medium" | "low"
              }
            ],

            "no_change": [
              {
                "path": "docs/projects/hakone-e2/project_definition.md",
                "reason": "今回の進捗ではこのドキュメントは変えなくてよいと判断した理由。"
              }
            ],

            "notes": [
              "補足メモ。仮定や前提条件など。"
            ]
          }

          JSON だけを出力してください。前後に説明文やコードフェンスは不要です。
          """)

          prompt = f"""
          対象プロジェクト: {project_id}

          以下の情報が与えられています。

          === 進捗サマリ ===
          {progress_summary}

          === project_definition (docs/projects/{project_id}/project_definition.md) ===
          {project_def}

          === STATE/current_state (STATE/{project_id}/current_state.md) ===
          {state}

          === latest weekly report (reports/{project_id}/*_weekly.md) ===
          {weekly}

          === PM Snapshot 仕様 (docs/pm/pm_snapshot_v1_spec.md) ===
          {pm_spec}

          === Layer B 更新フロー (docs/pm/layer_b_update_flow.md) ===
          {layer_b}

          あなたの役割は、「今回の進捗を踏まえて、どのドキュメントをどう更新すべきか」を判断し、
          doc_update_proposal_v1 のJSONとして提案することです。

          次の点に注意してください:
          - どのドキュメントを更新候補とみなすか、なぜそう判断したかを必ず書いてください。
          - 変える必要がないと判断したドキュメントについても、no_change に理由を書いてください（必要な範囲で）。
          - suggestion_markdown は、実際にコピペして使えるMarkdownの断片になるように書いてください。
          - 出力は doc_update_proposal_v1 の JSON オブジェクトのみとし、前後に何も付けないでください。

          {schema_desc}
          """.strip()

          out = base / "prompt.txt"
          out.write_text(prompt, encoding="utf-8")
          print(f"wrote prompt to {out}")
          PY

      - name: Call OpenAI for doc update proposal
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          PROJECT_ID: ${{ env.PROJECT_ID }}
        run: |
          set -e
          PROJECT_ID="${PROJECT_ID}"
          SNAP_DATE=$(date +%Y-%m-%d)
          mkdir -p reports/doc_update_proposals
          prompt="$(cat /tmp/doc-update-context/prompt.txt)"

          jq -n --arg sys "You are a Virtual Project Manager. Return only doc_update_proposal_v1 JSON." \
                --arg usr "$prompt" '{
            model:"gpt-5",
            response_format:{type:"json_object"},
            messages:[{role:"system",content:$sys},{role:"user",content:$usr}]
          }' > /tmp/doc-update-context/req.json

          curl -sS https://api.openai.com/v1/chat/completions \
            -H "Authorization: Bearer ${OPENAI_API_KEY}" \
            -H "Content-Type: application/json" \
            -d @/tmp/doc-update-context/req.json \
            | tee /tmp/doc-update-context/raw.json >/dev/null || true

          jq -r '.choices[0].message.content // ""' /tmp/doc-update-context/raw.json > /tmp/doc-update-context/proposal.txt

          # Strip outer fences if any
          awk 'NR==1{sub(/^```[a-zA-Z0-9_-]*[[:space:]]*/,"")} {buf=buf $0 ORS} END{sub(/```[[:space:]]*[\r\n]*$/,"",buf); printf "%s", buf}' \
            /tmp/doc-update-context/proposal.txt > /tmp/doc-update-context/proposal.clean.json

          SNAP_OUT="doc_update_proposal_v1.json"
          ARCHIVE_OUT="reports/doc_update_proposals/${SNAP_DATE}_${PROJECT_ID}.json"
          cp /tmp/doc-update-context/proposal.clean.json "$SNAP_OUT"
          cp /tmp/doc-update-context/proposal.clean.json "$ARCHIVE_OUT"

          echo "Saved proposal to $SNAP_OUT (archive: $ARCHIVE_OUT)"
          head -n 50 "$SNAP_OUT" || true

      - name: Upload doc update proposal artifact
        uses: actions/upload-artifact@v4
        with:
          name: doc_update_proposal_v1_${{ github.run_id }}
          path: doc_update_proposal_v1.json
          retention-days: 14

      - name: Mark Aya request as done on blackboard
        uses: actions/github-script@v7
        env:
          AYA_ENTRY: ${{ steps.find_aya_entry.outputs.aya_entry }}
          COMMENT_ID: ${{ steps.find_aya_entry.outputs.comment_id }}
          ISSUE_NUMBER: ${{ steps.find_aya_entry.outputs.issue_number }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const entry = JSON.parse(process.env.AYA_ENTRY || "{}");
            const commentId = parseInt(process.env.COMMENT_ID || "", 10);
            const issueNumber = parseInt(process.env.ISSUE_NUMBER || "", 10);
            if (!commentId || Number.isNaN(commentId)) {
              core.setFailed("comment_id is missing; cannot update blackboard entry.");
              return;
            }
            if (!issueNumber || Number.isNaN(issueNumber)) {
              core.setFailed("issue_number is missing; cannot update blackboard entry.");
              return;
            }

            const now = new Date().toISOString();
            entry.status = "done";
            entry.updated_at = now;

            const body = [
              "<!-- blackboard:doc_update_v1 -->",
              "",
              "json",
              JSON.stringify(entry, null, 2),
            ].join("\n");

            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: commentId,
              body,
            });

            core.info(`Updated Aya request comment ${commentId} on issue ${issueNumber} to status=done`);

      - name: Add Sho review_request blackboard comment
        uses: actions/github-script@v7
        env:
          AYA_ENTRY: ${{ steps.find_aya_entry.outputs.aya_entry }}
          ISSUE_NUMBER: ${{ steps.find_aya_entry.outputs.issue_number }}
          PROJECT_ID: ${{ env.PROJECT_ID }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issueNumber = parseInt(process.env.ISSUE_NUMBER || "", 10);
            if (!issueNumber || Number.isNaN(issueNumber)) {
              core.setFailed("issue_number is missing; cannot post Sho review_request.");
              return;
            }

            const requestEntry = JSON.parse(process.env.AYA_ENTRY || "{}");
            const requestId = requestEntry.id || `doc-update-${context.runId}`;
            const now = new Date().toISOString();

            const targetDocs = Array.isArray(requestEntry.target_docs) ? requestEntry.target_docs : [];
            const summary =
              (requestEntry.payload && typeof requestEntry.payload.summary === "string" && requestEntry.payload.summary) ||
              `Review request for blackboard entry ${requestId}`;

            const payloadRef = {
              type: "actions_artifact",
              workflow_run_id: context.runId,
              artifact_name: `doc_update_proposal_v1_${context.runId}`,
            };

            const entry = {
              id: `${requestId}-review`,
              from: "Aya",
              to: "Sho",
              project_id: process.env.PROJECT_ID,
              kind: "doc_update_review_request",
              status: "open",
              payload_ref: payloadRef,
              payload: {
                summary,
                refs: {
                  proposal_artifact_name: payloadRef.artifact_name,
                  proposal_workflow_run_id: payloadRef.workflow_run_id,
                  source_board_id: requestId,
                },
              },
              target_docs: targetDocs,
              created_at: now,
              updated_at: now,
            };

            const body = [
              "<!-- blackboard:doc_update_v1 -->",
              "",
              "json",
              JSON.stringify(entry, null, 2),
            ].join("\n");

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issueNumber,
              body,
            });

            core.info(`Posted Sho review_request entry with id ${entry.id} on issue ${issueNumber}`);
