#!/usr/bin/env python3
import argparse, base64, glob, json, os, subprocess, sys, time
from datetime import datetime
import shlex

ROOT = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))
ASK_DIR = os.path.join(ROOT, "reports", "ask")
THINK_DIR = os.path.join(ROOT, "reports", "think")

def sh(cmd, check=True, capture=False):
    print("+", cmd)
    if capture:
        return subprocess.check_output(cmd, shell=True, text=True)
    else:
        r = subprocess.run(cmd, shell=True)
        if check and r.returncode != 0:
            raise SystemExit(r.returncode)
        return r

def find_latest_ask(issue=None):
    files = sorted(glob.glob(os.path.join(ASK_DIR, "ask_*.json")))
    if not files: return None
    if issue is None:
        return files[-1]
    # issue番号を含むものを優先（ない場合は最新）
    for path in reversed(files):
        try:
            with open(path, "r") as f:
                j = json.load(f)
            meta = j.get("meta", {})
            if str(meta.get("issue")) == str(issue):
                return path
        except Exception:
            pass
    return files[-1]

def load_json(path):
    with open(path, "r") as f:
        return json.load(f)

def timestamp():
    return datetime.utcnow().strftime("%Y%m%dT%H%M%S")

def main():
    ap = argparse.ArgumentParser(description="Minimal Thinker: read U-Contract, draft a PR, write reports/think/*")
    ap.add_argument("--issue", type=str, default=None, help="target issue number (optional)")
    ap.add_argument("--dry-run", action="store_true", default=True, help="draft PR only; do not execute commands")
    ap.add_argument("--execute", action="store_true", default=False, help="execute plan.commands via safe executor")
    ap.add_argument("--once", action="store_true", default=True, help="run once and exit")
    args = ap.parse_args()

    os.makedirs(THINK_DIR, exist_ok=True)

    # 0) 最新の /ask を取得（ローカル最新化）
    sh("git fetch origin --quiet")
    sh("git switch -q main && git pull --ff-only --quiet || true")

    ask_path = find_latest_ask(args.issue)
    if not ask_path:
        print("[thinker] no reports/ask/ask_*.json found; abort", file=sys.stderr)
        return 1

    ask = load_json(ask_path)
    understanding = ask.get("understanding", "")
    commands = (ask.get("plan", {}) or {}).get("commands", []) or []

    ts = timestamp()
    branch = f"think/plan-{ts}"
    plan_md = os.path.join(THINK_DIR, f"plan_{ts}.md")
    think_json = os.path.join(THINK_DIR, f"think_{ts}.json")
    eval_json = os.path.join(THINK_DIR, f"eval_{ts}.json")

    # 1) 企画（plan）を Markdown に整形
    with open(plan_md, "w") as f:
        f.write("# Think Plan\n\n")
        f.write(f"- source_ask: `{os.path.relpath(ask_path, ROOT)}`\n")
        if args.issue: f.write(f"- issue: #{args.issue}\n")
        f.write(f"- dry_run: {bool(args.dry_run)}\n")
        f.write("\n## understanding\n")
        f.write(understanding.strip() + "\n\n")
        f.write("## plan.commands\n")
        if commands:
            for c in commands:
                f.write(f"- `{c}`\n")
        else:
            f.write("- (no commands)\n")

    # 2) thinkerレポート(JSON)
    with open(think_json, "w") as f:
        json.dump({
            "generated_at": datetime.utcnow().isoformat() + "Z",
            "source_ask": os.path.relpath(ask_path, ROOT),
            "issue": args.issue,
            "dry_run": bool(args.dry_run),
            "understanding": understanding,
            "plan": { "commands": commands }
        }, f, indent=2, ensure_ascii=False)

    # 3) ブランチ作成→コミット→Push→ドラフトPR
    sh("git fetch origin --quiet")
    sh(f"git switch -c {branch}")
    sh(f"git add {os.path.relpath(plan_md, ROOT)} {os.path.relpath(think_json, ROOT)}")
    sh(f'git commit -m "think: plan {ts} (draft via thinker)"')
    sh("git push -u origin HEAD")

    title = f"think: plan {ts}"
    body_path = os.path.join(THINK_DIR, f"body_{ts}.md")
    with open(body_path, "w") as bf:
        bf.write("Draft plan generated by Thinker.\n\n")
        bf.write(f"- source_ask: `{os.path.relpath(ask_path, ROOT)}`\n")
        bf.write(f"- dry_run: {bool(args.dry_run)}\n")

    pr_number = sh(f'gh pr create -t "{title}" --body-file "{body_path}" --draft', capture=True).strip()
    print("[thinker] draft PR created:", pr_number)

    # 4) 評価（最小）→ eval JSON 出力
    with open(eval_json, "w") as f:
        json.dump({
            "ready": True,              # 最小では常に ready（Dry-run）
            "notes": "draft PR created",
            "related_pr": int(pr_number.replace("#","")) if pr_number.startswith("#") else None,
            "source_ask": os.path.relpath(ask_path, ROOT)
        }, f, indent=2, ensure_ascii=False)

    # evalはPRに含めず、mainへの後続PRでまとめて入れる運用でもOK
    print("[thinker] outputs:")
    print(" -", os.path.relpath(plan_md, ROOT))
    print(" -", os.path.relpath(think_json, ROOT))
    print(" -", os.path.relpath(eval_json, ROOT))
    return 0

if __name__ == "__main__":
    sys.exit(main())
